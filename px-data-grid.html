<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../vaadin-grid/vaadin-grid.html">
<link rel="import" href="../vaadin-grid/vaadin-grid-sorter.html">
<link rel="import" href="../vaadin-grid/vaadin-grid-tree-toggle.html">
<link rel="import" href="../px-spinner/px-spinner.html">
<link rel="import" href="../px-modal/px-modal.html">
<link rel="import" href="../px-icon-set/px-icon.html"/>
<link rel="import" href="px-data-grid-column.html">
<link rel="import" href="px-auto-filter-field.html">
<link rel="import" href="px-data-grid-theme.html">
<link rel="import" href="px-data-grid-selection-column.html">
<link rel="import" href="px-data-grid-toggle-details-column.html">
<link rel="import" href="../app-localize-behavior/app-localize-behavior.html"/>

<link rel="import" href="px-data-grid-string-renderer.html">
<link rel="import" href="px-data-grid-date-renderer.html">
<link rel="import" href="px-data-grid-number-renderer.html">
<link rel="import" href="px-data-grid-cell-content-wrapper.html">
<link rel="import" href="px-data-grid-filter.html">
<link rel="import" href="px-data-grid-filters-preview.html">
<link rel="import" href="px-data-grid-sorter.html">
<link rel="import" href="px-data-grid-edit-buttons.html">

<link rel="import" href="css/px-data-grid-styles.html">

<dom-module id="px-data-grid">
  <template>
    <style include="px-data-grid-styles"></style>

    <px-modal
      id="filtersModal"
      header-text="Filter Columns"
      open-trigger="[[filtersModalTrigger]]">
      <div slot="body">
        <px-data-grid-filter id="filters" columns="[[columns]]" filters="{{filters}}"></px-data-grid-filter>
        <div class="filter-modal-buttons-container">
          <button class="btn" on-click="_resetFilters">Reject</button>
          <div class="filter-modal-buttons-container__right">
            <button class="btn" on-click="_cancelFilterChanges">Cancel</button>
            <button class="btn btn--call-to-action" on-click="_applyFilters">Accept</button>
          </div>
        </div>
      </div>
      <div slot="reject-trigger"></div>
      <div slot="accept-trigger"></div>
    </px-modal>

    <px-data-grid-filters-preview filters="[[filters]]" columns="[[columns]]"></px-data-grid-filters-preview>

    <template is="dom-if" if="{{_showActionBar(autoFilter, actionMenu, filterable)}}">

      <div class="action-bar">
        <template is="dom-if" if="[[autoFilter]]">
          <px-auto-filter-field
            placeholder="[[localize('Filter')]]"
            on-filter-change="_autoFilterChanged"
            value="{{_autoFilterValue}}"
          >
          </px-auto-filter-field>
        </template>

        <div class="action-bar__right">
          <template is="dom-if" if="[[filterable]]">
            <px-modal-trigger trigger="{{filtersModalTrigger}}">
              <button class="btn">
                <px-icon style="--iron-icon-height:16px" icon="px-utl:filter"></px-icon> [[localize('Table Filters')]]
              </button>
            </px-modal-trigger>
          </template>

          <template is="dom-if" if="[[actionMenu]]">
            <px-dropdown multi hide-selected
              display-value="[[localize('Actions')]]"
              items="[[_actionMenuContent]]"
              selected-values="[[_selectedActionItems]]"
              disable-clear
              on-px-dropdown-click="_actionClicked">
            </px-dropdown>
          </template>
        </div>

      </div>
    </template>
    <vaadin-grid size="[[size]]"
                 data-provider="[[_currentDataProvider]]"
                 active-item="[[activeItem]]"
                 column-reordering-allowed="[[columnReorderingAllowed]]"
                 expanded-items="[[expandedItems]]"
                 striped$="[[striped]]"
                 selected-items="{{selectedItems}}"
                 multi-sort="[[multiSort]]"
                 item-id-path="[[itemIdPath]]"
                 auto-height$="[[autoHeight]]"
                 loading="{{_loading}}">

      <template is="dom-if" if="[[_isSelectable(selectionMode)]]" restamp>
        <px-data-grid-selection-column frozen auto-select hidden="[[hideSelectionColumn]]" multi-select="[[_isMultiSelect(selectionMode)]]" tree-grid="[[_groupByColumn]]">
        </px-data-grid-selection-column>
      </template>

      <template is="dom-if" if="[[rowDetails]]" restamp>
        <px-data-grid-toggle-details-column frozen>
        </px-data-grid-toggle-details-column>
      </template>

      <template is="dom-repeat" items="[[columns]]" as="column">
        <px-data-grid-column
          resizable="[[resizable]]"
          name="[[column.name]]"
          path="[[column.path]]"
          hidden="[[column.hidden]]"
          localize="[[_boundedLocalize]]"
          type="[[column.type]]"
          frozen="[[_undefinedToFalse(column.frozen)]]"
          mapped-object="[[column]]"
          width="[[_getColumnWidth(column)]]"
          flex-grow="[[_getColumnFlexGrow(column)]]"
          on-column-change="_onColumnUpdate"
          is-remote-data-provider="[[!_hasLocalDataProvider]]"
          is-data-column="true">
          <template class="header">
            <px-data-grid-sorter path="[[_resolveColumnPath(column)]]">[[_resolveColumnHeader(column)]]</px-data-grid-sorter>
          </template>

          <template>

            <dom-if if="[[_isGroupedByColumn(column, _groupByColumn)]]">
              <template>
                <vaadin-grid-tree-toggle leaf="[[!item.hasChildren]]" expanded="{{expanded}}" level="[[level]]">
                  <template is="dom-if" if="[[item.hasChildren]]">
                    <template is="dom-if" if="[[!expanded]]">
                      <px-icon icon="px-utl:chevron-right"></px-icon>
                    </template>
                    <template is="dom-if" if="[[expanded]]">
                      <px-icon icon="px-utl:chevron"></px-icon>
                    </template>
                  </template>
                  <px-data-grid-cell-content-wrapper cell-color="[[_resolveCellColor(item, column, _highlightEntities.*)]]" item="{{item}}" column="[[column]]" localize="[[_boundedLocalize]]">
                  </px-data-grid-cell-content-wrapper>
                </vaadin-grid-tree-toggle>
              </template>
            </dom-if>

            <dom-if if="[[!_isGroupedByColumn(column, _groupByColumn)]]">
              <template>
                <px-data-grid-cell-content-wrapper cell-color="[[_resolveCellColor(item, column, _highlightEntities.*)]]" item="{{item}}" column="[[column]]" localize="[[_boundedLocalize]]">
                </px-data-grid-cell-content-wrapper>
              </template>
            </dom-if>
          </template>
        </px-data-grid-column>
      </template>

      <template is="dom-if" if="[[editable]]" restamp>
        <px-data-grid-column
          flex-grow="0">
          <template>
            <dom-if if="[[!_isAnyItemEditing(_editingItem)]]">
              <template>
                <px-icon icon="px-utl:edit" on-click="_setEditingItem"></px-icon>
              </template>
            </dom-if>
            <dom-if if="[[_isItemEditing(item, _editingItem)]]">
              <template>
                <px-data-grid-edit-buttons save="[[_boundedSaveItem]]" cancel="[[_boundedCancelEdit]]"></px-data-grid-edit-buttons>
              </template>
            </dom-if>
          </template>
        </px-data-grid-column>
      </template>
    </vaadin-grid>

    <px-spinner size="40" hidden$="[[_spinnerHidden]]"></px-spinner>
  </template>
  <script>
    {
      class DataGridElement extends Polymer.mixinBehaviors([Polymer.AppLocalizeBehavior], Polymer.Element) {

        static get is() {
          return 'px-data-grid';
        }

        static get properties() {
          return {

            /**
             * Data for the table to display.
             *
             * Expected data format is a JSON array of objects. Each object in the array represents a row in the table.
             *
             * Each item in an object will be displayed as a separate column, unless px-data-table-columns are
             * defined to limit which columns are displayed.
             */
            tableData: {
              type: Array,
              notify: true
            },

            /**
             * If true, turns on advanced filtering feature.
             */
            filterable: {
              type: Boolean,
              value: false
            },

            /**
             * If true, hides the column with checkboxes.
             */
            hideSelectionColumn: {
              type: Boolean,
              value: false
            },

            /**
             * An array that contains the selected items.
             */
            selectedItems: {
              type: Array,
              value: () => [],
              notify: true
            },

            /**
             * The total number of items
             */
            size: {
              type: Number,
              value: undefined
            },

            /**
             * Number of items fetched at a time from the dataprovider.
             */
            pageSize: {
              type: Number,
              value: undefined
            },

            /**
             * When `true`, user can sort by multiple columns
             */
            multiSort: {
              type: Boolean,
              value: false
            },

            /**
             * Current selection mode of grid. Accepts values 'none', 'single' and 'multi'.
             */
            selectionMode: {
              type: String,
              value: 'none',
              observer: '_selectionModeChanged'
            },

            /**
             * The item user has last interacted with. Turns to `null` after user deactivates
             * the item by re-interacting with the currently active item.
             */
            activeItem: {
              type: Object,
              notify: true,
              value: null
            },

            /**
             * When `true`, user can resize columns
             */
            resizable: {
              type: Boolean,
              value: false
            },

            /**
             * When `true`, user can edit data
             */
            editable: {
              type: Boolean,
              value: false
            },

            /**
             * Set to true to allow column reordering.
             */
            columnReorderingAllowed: {
              type: Boolean,
              value: false
            },

            /**
             * An array containing references to expanded items.
             */
            expandedItems: {
              type: Array,
              value: []
            },

            /**
             * Set to true to enable a togglable row details container. This container
             * is hidden by default, but can be opened by clicking the chevron icon to left
             * of the row.
             */
            rowDetails: {
              type: Boolean,
              value: false,
              observer: '_onRowDetailsChange'
            },

            /**
             * Define if table action menu is shown or not
             */
            actionMenu: {
              type: Boolean,
              value: false
            },

            /**
             * Grid columns. If no columns are passed, grid generates columns from passed data.
             * Format:
             * ```javascript
             * {
             *   name: 'First Name',
             *   path: 'first',
             *   hidden: false,
             *   frozen: false,
             *   required: false,
             *   flexGrow: 1
             * }
             * ```
             */
            columns: {
              type: Array,
              value: () => [],
              observer: '_columnsChanged'
            },

            /**
             * Copy of last columns value received, to be used with reset layout
             */
            _lastColumnsReceived: {
              type: Array,
              value: () => []
            },

            /**
             * Content of action menu
             */
            _actionMenuContent: {
              type: Array
            },

            /**
             * A valid IETF language tag as a string that `app-localize-behavior` will
             * use to localize this component.
             *
             * See https://github.com/PolymerElements/app-localize-behavior for API
             * documentation and more information.
             */
            language: {
              type: String,
              value: 'en'
            },

            /**
             * Use the key for localization if value for that language is missing.
             * Should always be true for Predix components.
             */
            useKeyIfMissing: {
              type: Boolean,
              value: true
            },

            /**
             * Library object of hardcoded strings used in this application.
             * Used by `app-localize-behavior` in conjunction with `language`.
             */
            resources: {
              type: Object,
              value: () => {
                // can also load these from external file as shown here:
                // https://www.polymer-project.org/2.0/toolbox/localize
                return {
                  'en': {
                    'Actions': 'Actions',
                    'Freeze column': 'Freeze column',
                    'Unfreeze column': 'Unfreeze column',
                    'Group by column': 'Group by column',
                    'Ungroup': 'Ungroup',
                    'Hide column': 'Hide column'
                  },
                  'fr': {
                    'Actions': 'Actions',
                    'Value is required': 'Pakollinen arvo'
                  },
                  'fi': {
                    'Actions': 'Toiminnot',
                    'Hide column': 'Piilota sarake'
                  }
                };
              }
            },

            /**
             * All custom table actions shown before columns. Arrays should contain objects
             * with name (String, shown to user) and id (String, given back in event).
             * When user selects these actions table-action event will be emitted, with id of
             * action at event.detail.id
             */
            tableActions: {
              type: Array,
              value: []
            },

            /**
             * Function that provides items lazily. Receives arguments params, callback
             */
            remoteDataProvider: {
              type: Function,
              observer: '_remoteDataProviderChanged'
            },

            _currentDataProvider: {
              type: Function
            },

            /**
             * If true, every other row in the table will appear with a background color to improve visual scanning.
             */
            striped: {
              type: Boolean,
              value: false
            },

            /**
             * Shows if there is any pending request for remote data.
             */
            _loading: {
              type: Boolean,
              value: false,
              observer: '_loadingChanged'
            },

            _spinnerHidden: {
              type: Boolean,
              value: true
            },

            /**
             * How many milliseconds before loading spinner will be shown
             */
            loadingSpinnerDebounce: {
              type: Number,
              value: 500
            },

            /**
             * To enable automatic filtering change property to true
             */
            autoFilter: {
              type: Boolean,
              value: false
            },

            /**
             * Array of objects of conditions used to highlight specific columns.
             * Format:
             * ```javascript
             * {
             *   type: 'cell',
             *   condition: (cellContent, column, item) => { return cellContent == 'John Doe' },
             * },
             * {
             *   type: 'row',
             *   condition: (cellContent, item) => { return cellContent[0] == 'a' },
             *   color: '#a8a8a8'
             * },
             * {
             *   type: 'column',
             *   condition (column, item) => { return column.name == 'age' },
             *   color: 'pink'
             * }
             * ```
             */
            highlight: {
              type: Array,
              value: () => []
            },

            /**
             * Concatenated array from user's highlights and filter's
             */
            _highlightEntities: {
              type: Array,
              value: () => []
            },

            /**
             * Array of highlights from px-data-grid-filter component
             */
            _filterHighlights: {
              type: Array,
              value: () => []
            },

            /**
             * When true data provider is local, when false external (remote) and
             * when undefined it defined yet.
             */
            _hasLocalDataProvider: {
              type: Boolean
            },

            /**
             * Default column width if not defined, eg. '100px'
             */
            defaultColumnWidth: {
              type: String,
              value: '100px'
            },

            /**
             * Default column flex if not defined, eg. 1
             */
            defaultColumnFlex: {
              type: Number,
              value: 1
            },

            _selectedActionItems: {
              type: Array,
              value: []
            },

            _groupByColumn: {
              type: Object,
              value: false
            },

            /**
             * Array of filters from px-data-grid-filter component.
             * Format for string column.type:
             * ```
             * {
             *   action: 'show',
             *   column: {
             *     type: 'string',
             *     path: 'last'
             *   },
             *   pattern: 'equals',
             *   query: 'Wong',
             * }
             * ```
             * Pattern can be one of `['equals', 'contains', 'starts_with', 'ends_with', 'wildcard']`.
             * Format for date column.type:
             * ```
             * {
             *   action: 'hide',
             *   column: {
             *     type: 'date',
             *     path: 'birth_date'
             *   },
             *   dateFrom: '1994-11-12',
             *   dateTo: '1994-11-12'
             * }
             * ```
             * Format for number column.type:
             * ```
             * {
             *   action: 'highlight',
             *   column: {
             *     type: 'number',
             *     path: 'age'
             *   },
             *   leftBound: 11,
             *   rightBound: 12
             * }
             * ```
             */
            filters: {
              type: Array,
              value: () => [{entities: [{}], action: 'show', operationType: 'all'}]
            },

            /**
             * Grid auto resize height to match number of rows.
             */
            autoHeight: {
              type: Boolean,
              value: false,
              reflectToAttribute: true,
              observer: '_autoHeightChanged'
            },

            /**
             * Path to an item sub-property that identifies the item.
             */
            itemIdPath: {
              type: String,
              value: null
            },

            /**
             * Stores item, that is currently in edit mode.
             */
            _editingItem: {
              type: Object,
              value: null,
              observer: '_editingItemObserver'
            },

            /**
             * Stores all renderer elements for item, that is currently in edit mode.
             */
            _editingRenderers: {
              type: Array,
              value: () => []
            },

            _boundedLocalize: Function,

            _autoFilterValue: {
              type: String
            }
          };
        }

        static get observers() {
          return [
            '_filtersObserver(filters, filters.*)',
            '_highlightsObserver(highlight, _filterHighlights, highlight.*, _filterHightlights.*)',
            '_localizeChanged(localize)',
            '_tableDataChanged(tableData, isAttached)',
            '_setColumnId(columns, columns.*)'
          ];
        }

        updateColumns() {
          const probs = ['hidden', 'name', 'frozen', 'width', 'flexGrow', 'path'];
          for (let i = 0; i < this.columns.length; ++i) {
            const prefix = 'columns.' + i + '.';
            probs.forEach(prob => {
              const path = prefix + prob;
              this.notifyPath(path);
            });
          }
        }

        constructor() {
          super();
          this._observer = new Polymer.FlattenedNodesObserver(this, info => {
            this._checkRowDetailsTemplate(info.addedNodes);
          });
        }

        _checkRowDetailsTemplate(nodes) {
          const rowDetailsTemplate = nodes.filter(node => {
            return node.localName && node.localName === 'template' && node.className && node.className.indexOf('row-details') !== -1;
          });
          if (rowDetailsTemplate.length) {
            this._vaadinGrid._rowDetailsTemplate = rowDetailsTemplate[0];

            const templatizer = new Vaadin.Grid.Templatizer();
            templatizer._grid = this._vaadinGrid;
            templatizer.dataHost = this._vaadinGrid.dataHost;
            templatizer.template = this._vaadinGrid._rowDetailsTemplate;
            this._vaadinGrid._rowDetailsTemplate.templatizer = templatizer;

            Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => {
              Array.from(this._vaadinGrid.$.items.children).forEach(row => {
                this._vaadinGrid._updateRow(
                  row,
                  this._vaadinGrid._columnTree[this._vaadinGrid._columnTree.length - 1]
                );
              });
            });
          }
        }

        ready() {
          super.ready();

          this._vaadinGrid = this.shadowRoot.querySelector('vaadin-grid');
          this._vaadinGrid._pxDataGrid = this;
          this._vaadinGrid.addEventListener('px-sorter-changed', this._onPxSorterChanged);

          // Attach scroll listener for styling
          this._boundedScrollListener = this._scrollListener.bind(this);
          this._vaadinGrid.$.outerscroller.addEventListener('scroll', this._boundedScrollListener);

          // Override selectItem method to allow easy single select handling
          this._vaadinGrid.selectItem = (item) => this._handleSelectItem(item);

          this.addEventListener('column-froze', (event) => this._handleColumnFroze(event));

          this.addEventListener('column-unfroze', (event) => {
            const columnsRow = this._vaadinGrid._columnTree[this._vaadinGrid._columnTree.length - 1].slice(0);
            const lastFrozen = columnsRow.filter((column) => column._lastFrozen)[0];
            if (lastFrozen) {
              this._vaadinGrid.insertBefore(event.detail.column, lastFrozen.nextSibling);
            }
          });

          this.addEventListener('group-by-column', (event) => {
            this._groupByColumn = event.detail.column;
            this._vaadinGrid.clearCache();
            this._vaadinGrid.setAttribute('tree-grid', true);
          });

          this.addEventListener('ungroup', (event) => {
            this._ungroup();
          });

          this.addEventListener('trigger-filters-modal', (event) => {
            this.$.filtersModal.opened = true;
          });

          this.addEventListener('remove-filter', (event) => {
            const entity = event.detail.entity;
            const section = event.detail.section;
            const sectionIndex = this.filters.indexOf(section);
            this.splice(`filters.${sectionIndex}.entities`, section.entities.indexOf(entity), 1);
          });

          this._boundedCancelEdit = this._cancelEdit.bind(this);
          this._boundedSaveItem = this._saveItem.bind(this);

          document.addEventListener('renderer-editing-changed', (event) => {
            const renderer = event.detail.renderer;
            if (renderer._editing) {
              this._editingRenderers.push(renderer);
            } else {
              this._editingRenderers.splice(this._editingRenderers.indexOf(renderer), 1);
            }
          });
        }

        _applyFilters() {
          this.$.filters.applyFilters();
          this.$.filtersModal.opened = false;
        }

        _cancelFilterChanges() {
          this.$.filters.cancelChanges();
          this.$.filtersModal.opened = false;
        }

        _resetFilters() {
          this.$.filters.resetFilters();
          this.$.filtersModal.opened = false;
        }

        _ungroup() {
          this._groupByColumn = false;
          this._vaadinGrid.clearCache();
          this._vaadinGrid.removeAttribute('tree-grid');
        }

        _handleColumnFroze(event) {
          const columnsRow = this._vaadinGrid._columnTree[this._vaadinGrid._columnTree.length - 1].slice(0);
          const dataColumns = columnsRow.filter(c => c.isDataColumn);
          if (dataColumns.length) {
            this._vaadinGrid.insertBefore(event.detail.column, dataColumns[0]);
            Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this._vaadinGrid.notifyResize());
          }
        }

        /**
         * Trick to prevent multiselection when in single select mode
         */
        _handleSelectItem(item) {
          if (!this._vaadinGrid._isSelected(item)) {
            if (!this._isMultiSelect()) {
              this._vaadinGrid.selectedItems = [];
            }
            this._vaadinGrid.push('selectedItems', item);
          }
        }

        _getValue(column, item) {
          if (column && item) {
            return this.get(column.path, item);
          } else {
            return undefined;
          }
        }

        _getColumnWidth(column) {
          return column.width ? column.width : this.defaultColumnWidth;
        }

        _getColumnFlexGrow(column) {
          return column.flexGrow === undefined ? this.defaultColumnFlex : column.flexGrow;
        }

        _resolveCellColor(item, column) {
          if (!this._highlightEntities || item === undefined) {
            return undefined;
          }

          let columnColor;
          let rowColor;
          let cellColor;

          this._highlightEntities.forEach((highlightEntity) => {
            if (highlightEntity.type === 'row') {
              if (this._isRowConditionApplied(item, highlightEntity.condition)) {
                if (highlightEntity.color) {
                  rowColor = highlightEntity.color;
                } else {
                  rowColor = 'default';
                }
              }
            } else if (highlightEntity.type === 'column') {
              if (this._isColumnConditionApplied(column, highlightEntity.condition)) {
                if (highlightEntity.color) {
                  columnColor = highlightEntity.color;
                } else {
                  columnColor = 'default';
                }
              }
            } else {
              const value = this._getValue(column, item);
              if (highlightEntity.condition(value, column, item)) {
                if (highlightEntity.color) {
                  cellColor = highlightEntity.color;
                } else {
                  cellColor = 'default';
                }
              }
            }
          });

          const finalColor = cellColor ? cellColor : (rowColor ? rowColor : (columnColor ? columnColor : undefined));
          return finalColor;
        }

        _isRowConditionApplied(item, condition) {
          return !!this.columns.filter(column => {
            const cellText = this.get(column.name, item);
            return condition(cellText, item);
          }).length;
        }

        _isColumnConditionApplied(column, condition) {
          const cachedItems = this._vaadinGrid._cache.items;
          const itemsArray = Object.keys(cachedItems).map(key => cachedItems[key]);

          return !!itemsArray.filter(item => {
            return condition(column, item);
          }).length;
        }

        _tableDataChanged(tableData, isAttached) {
          if (!isAttached) {
            return;
          }

          if (tableData) {
            this._currentDataProvider = (params, callback) => {
              this._localDataProvider(params, (items, size) => {
                callback(items, size);
                this._populateTableColumns(items);
              });
            };
            this._hasLocalDataProvider = true;
          }
          this._editingItem = null;
        }

        _localDataResolver(params, items) {
          if (params.filters && params.filters.length && this._vaadinGrid._checkPaths(params.filters, 'filtering', items)) {
            items = this._applyAutoFilter(items, params.filters);
          }

          if (this.filters && this.filters.length != 0) {
            items = this._applyCustomFilter(items, this.filters);
          }

          if (params.sortOrders && params.sortOrders.length && this._vaadinGrid._checkPaths(this._sorters, 'sorting', items)) {
            const multiSort = (a, b) => {
              return params.sortOrders.map(sort => {
                if (sort.direction === 'asc') {
                  return this._vaadinGrid._compare(Polymer.Base.get(sort.path, a), Polymer.Base.get(sort.path, b));
                } else if (sort.direction === 'desc') {
                  return this._vaadinGrid._compare(Polymer.Base.get(sort.path, b), Polymer.Base.get(sort.path, a));
                }
                return 0;
              }).reduce((p, n) => {
                return p ? p : n;
              }, 0);
            };

            items = items.slice(0).sort(multiSort);
          }

          const start = params.page * params.pageSize;
          const end = start + params.pageSize;

          return items.slice(start, end);
        }

        _localDataProvider(params, callback) {
          let items = Array.isArray(this.tableData) ? this.tableData : [];
          if (this._groupByColumn) {
            const columnPath = this._groupByColumn.path;
            if (!params.parentItem) {
              const valuesMap = items.reduce((map, item) => {
                const value = item[columnPath];
                const groupItem = Object.assign({}, item);
                for (const i in groupItem) { // px-data-grid/issues/160
                  if (i !== columnPath) {
                    groupItem[i] = '';
                  }
                }
                groupItem.hasChildren = true;
                map.set(value, groupItem);
                return map;
              }, new Map());
              items = [];
              valuesMap.forEach((item) => items.push(item));
            } else {
              items = items.filter((item) => item[columnPath] === params.parentItem[columnPath]);
            }
          }
          items = this._localDataResolver(params, items);
          callback(items, items.length);
        }

        /**
         * Will return all local items after filter (no ordering applied)
         */
        _getAllLocalItems() {
          if (this._hasLocalDataProvider) {
            const items = (Array.isArray(this.tableData) ? this.tableData : []).slice(0);
            return this._localDataResolver({
              page: 0,
              pageSize: this.tableData.length
            }, items);
          } else {
            return [];
          }
        }

        _remoteDataProviderChanged(provider) {
          this._hasLocalDataProvider = false;
          this._currentDataProvider = (params, callback) => {
            provider(params, (items, size) => {
              callback(items, size);
              this._populateTableColumns(items);
            });
          };
        }

        _resolveColumnPath(column) {
          if (typeof column.path === 'undefined') {
            console.warn(`column.path for column ${JSON.stringify(column)} should be initialized.`);
          }
          return column.path ? column.path : '';
        }

        _populateTableColumns(data) {
          if (!this.columns.length && data && data.length) {
            this.columns = [];
            for (const key in data[0]) {
              this.push('columns', {
                name: key,
                hidden: false,
                type: 'string',
                path: key,
                generated: true
              });
            }
          }

          this._updateActionMenu();
        }

        /**
         * Event handler for action menu clicks
         */
        _actionClicked(evt) {
          const item = evt.detail.detail.item;
          const key = item.key;

          if (key && typeof key == 'string') {
            // -column- is temporary work around to limitations of px-dropdown
            if (key.indexOf('-column-') === 0) {
              const columnName = key.substr('-column-'.length);
              this._getColumnsWithName(columnName).forEach((c) => {
                c.hidden = c.hidden === undefined ? true : !c.hidden;
              });
            } else if (key.indexOf('-action-') === 0) {
              const actionId = key.substr('-action-'.length);
              this.dispatchEvent(new CustomEvent('table-action', {
                detail: {
                  id: actionId
                },
                bubbles: true
              }));
            } else if (key.indexOf('-internal-ungroup-') === 0) {
              this._ungroup();
            }
          }
        }

        /**
         * Function to resolve (data) columns on grid
         */
        _getColumns() {
          if (this._vaadinGrid && this._vaadinGrid._columnTree) {
            return this._vaadinGrid._columnTree[0].filter(c => c.isDataColumn);
          } else if (this.columns && this.columns.length) {
            return this.columns.map((c) => {
              return c._element ? c._element : c;
            });
          } else {
            return [];
          }
        }

        /**
         * Function called when action menu content needs to be updated
         */
        _updateActionMenu() {
          const content = [];
          this._selectedActionItems = [];

          // Application specific options

          if (this.tableActions) {
            this.tableActions.forEach((item) => {
              content.push({
                key: '-action-' + item.id,
                val: item.name,
                selected: false,
                disabled: true
              });
            });
          }

          if (this._groupByColumn) {
            content.push({
              key: '-internal-ungroup-',
              val: this.localize('Clear Grouping'),
              selected: false,
              disabled: true
            });
          }

          // Add column hide/show selection

          const defaultName = this.localize('Column #');
          let counter = 0;
          const selected = [];

          this._getColumns().forEach((columnElement) => {
            const index = ++counter;
            const hidden = columnElement.hidden ? columnElement.hidden : false;
            const name = columnElement.name ? columnElement.name : (defaultName + index);
            // -column- is temporary work around to limitations of px-dropdown
            const key = '-column-' + name;

            const item = {
              key: key,
              val: name
            };

            if (!hidden) {
              selected.push(key);
            }

            content.push(item);
          });

          this._actionMenuContent = content;
          this._selectedActionItems = selected;
        }

        _getColumnsWithName(name) {
          return this._getColumns().filter(c => c.name == name);
        }

        _getColumnById(columnId) {
          return this.columns.filter((column) => column.id === columnId)[0];
        }

        _onColumnUpdate(event) {
          if (event.detail.type == 'hidden') {
            this._updateActionMenu();
          }
        }

        _loadingChanged(loading) {
          clearTimeout(this._spinnerHiddenTimeout);

          if (loading) {
            this._spinnerHiddenTimeout = setTimeout(() => this._spinnerHidden = false, this.loadingSpinnerDebounce);
          } else {
            this._spinnerHidden = true;
          }
        }

        /**
         * Simple method to check if action bar should be shown
         */
        _showActionBar(filterField, actionDropDown, filterable) {
          return filterField || actionDropDown || filterable;
        }

        /**
         * Helper method to check if header is defined, if not use name
         */
        _resolveColumnHeader(column) {
          return column.header ? column.header : column.name;
        }

        /**
         * This to be moved to inner data-provider when we get that done. Until then
         * this will add workaround that allows to filter inmemory data given via
         * items parameter.
         */
        _applyAutoFilter(items, filters) {
          return items.filter((item, index) => {
            return filters.filter(filter => {
              const filterValueLowercase = this._vaadinGrid._normalizeEmptyValue(filter.value).toString().toLowerCase();
              if (item && filter.path === undefined) {
                for (const key in item) {
                  const value = this._vaadinGrid._normalizeEmptyValue(Polymer.Base.get(key, item));
                  if (value.toString().toLowerCase().indexOf(filterValueLowercase) !== -1) {
                    return false;
                  }
                }
                return true;
              } else {
                const value = this._vaadinGrid._normalizeEmptyValue(Polymer.Base.get(filter.path, item));
                return value.toString().toLowerCase().indexOf(filterValueLowercase) === -1;
              }
            }).length === 0;
          });
        }

        _escapeRegExp(str) {
          return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
        }

        _isStringMatches(filter, value) {
          let regex;

          switch (filter.pattern) {
            case 'equals':
              regex = new RegExp(`^${this._escapeRegExp(filter.query)}$`, 'i');
              break;
            case 'contains':
              regex = new RegExp(`${this._escapeRegExp(filter.query)}`, 'i');
              break;
            case 'starts_with':
              regex = new RegExp(`^${this._escapeRegExp(filter.query)}`, 'i');
              break;
            case 'ends_with':
              regex = new RegExp(`${this._escapeRegExp(filter.query)}$`, 'i');
              break;
            case 'wildcard':
              regex = new RegExp(`${filter.query.split('*').map(this._escapeRegExp).join('.*')}`, 'i');
              break;
          }

          return regex.test(value);
        }

        _isDateMatches(filter, value) {
          let result = true;
          const comparingDate = new Date(value);
          if (filter.dateFrom) {
            const dateFrom = new Date(filter.dateFrom);
            result = result && dateFrom < comparingDate;
          }
          if (filter.dateTo) {
            const dateTo = new Date(filter.dateTo);
            result = result && dateTo > comparingDate;
          }
          return result;
        }

        _isNumberMatches(filter, value) {
          let result = true;
          const comparingNumber = window.parseInt(value);
          if (filter.leftBound) {
            const leftBound = window.parseInt(filter.leftBound);
            result = result && leftBound <= comparingNumber;
          }
          if (filter.rightBound) {
            const rightBound = window.parseInt(filter.rightBound);
            result = result && rightBound >= comparingNumber;
          }
          return result;
        }

        _applyCustomFilter(items, filters) {
          const appliableFilters = filters
            .filter((section) => ['show', 'hide'].indexOf(section.action) !== -1)
            .filter((section) => section.entities.filter((entity) => entity.active).length > 0);

          const filteredItems = items.filter((item) => {
            if (appliableFilters.length === 0) {
              return true;
            }

            const isAnySectionApplied = appliableFilters
              .some((section) => {
                const activeEntities = section.entities.filter((entity) => entity.active);

                return activeEntities[section.operationType === 'any' ? 'some' : 'every']((entity) => {
                  const column = this._getColumnById(entity.columnId);
                  const filteringValue = Polymer.Path.get(item, column.path);

                  if (column.type === 'date') {
                    const dateTest = this._isDateMatches(entity, filteringValue);
                    return ((section.action === 'show' && dateTest) || (section.action === 'hide' && !dateTest));
                  } else if (column.type === 'number') {
                    const numberTest = this._isNumberMatches(entity, filteringValue);
                    return ((section.action === 'show' && numberTest) || (section.action === 'hide' && !numberTest));
                  } else {
                    const regexTest = this._isStringMatches(entity, filteringValue);
                    return ((section.action === 'show' && regexTest) || (section.action === 'hide' && !regexTest));
                  }
                });
              });

            return isAnySectionApplied;
          });

          return filteredItems;
        }

        /**
         * Listener for auto filter component
         */
        _autoFilterChanged(event) {
          // Ignore if autofiltering not enabled
          if (!this.autoFilter) {
            return;
          } else {
            const filters = [
              {
                value: event.detail.value
              }
            ];

            this._vaadinGrid._filters = filters;
            this._vaadinGrid.clearCache();
          }
        }

        _isGroupedByColumn(column, _groupByColumn) {
          return _groupByColumn && _groupByColumn.name === column.name;
        }

        /**
         * Method forcing column order rules. To be run after any column order change
         */
        _columnOrderCleaner() {
          const columnsRow = this._vaadinGrid._columnTree[this._vaadinGrid._columnTree.length - 1].slice(0);
          const leftColumns = columnsRow.filter(c => !c.isDataColumn && c.frozen);
          const rightColumns = columnsRow.filter(c => c.isDataColumn || !c.frozen);

          if (leftColumns && leftColumns.length && rightColumns && rightColumns.length) {
            const firstRight = rightColumns[0];
            leftColumns.forEach(c => {
              this._vaadinGrid.insertBefore(c, firstRight);
            });
          }
        }

        /**
         * Check if selections are allowed
         */
        _isSelectable() {
          return this.selectionMode == 'single' || this.selectionMode == 'multi';
        }

        /**
         * Check if grid is in multi selection mode
         */
        _isMultiSelect() {
          return this._isSelectable() && this.selectionMode == 'multi';
        }

        _selectionModeChanged(mode) {
          if (mode != 'none' && mode != 'single' && mode != 'multi') {
            console.warn('Invalid selection-mode value \'' + mode + '\', use \'none\', \'single\' or \'multi\'');
            return;
          }

          const selectable = mode != 'none';

          // clear selections if mode is 'none'
          if (mode === 'none' && this._vaadinGrid) {
            this._vaadinGrid.selectedItems = [];
          }

          // clear selections if mode is 'single' and there are more than 1 selected items
          if (mode === 'single' && this._vaadinGrid && this._vaadinGrid.selectedItems.length > 1) {
            this._vaadinGrid.selectedItems = [];
          }

          if (selectable) {
            setTimeout(() => {
              if (this.selectable) {
                this._columnOrderCleaner();
              }
            });
          }

          Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this._vaadinGrid.notifyResize());
        }

        _highlightsObserver(highlight, filterHighlights) {
          this.set('_highlightEntities', highlight.concat(filterHighlights));
        }

        _filtersObserver(filters) {
          if (!this._vaadinGrid) {
            return;
          }

          const appliableFilters = filters
            .filter((section) => section.action === 'highlight' && section.entities.filter((entity) => entity.active).length > 0);

          if (appliableFilters.length > 0) {
            const condition = (cellContent, item) => {
              return appliableFilters.some((section) => {
                const activeEntities = section.entities.filter((entity) => entity.active);

                return activeEntities[section.operationType === 'any' ? 'some' : 'every']((entity) => {
                  const column = this._getColumnById(entity.columnId);
                  const filteringValue = Polymer.Path.get(item, column.path);

                  if (column.type === 'date') {
                    return this._isDateMatches(entity, filteringValue);
                  } else if (column.type === 'number') {
                    return this._isNumberMatches(entity, filteringValue);
                  } else {
                    return this._isStringMatches(entity, filteringValue);
                  }
                });
              });
            };

            this.set('_filterHighlights', [
              {
                type: 'row',
                condition: condition
              }
            ]);
          }

          this._vaadinGrid.clearCache();
        }

        _autoHeightChanged(autoHeight) {
          if (!this._vaadinGrid) {
            return;
          }

          Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this._vaadinGrid.notifyResize());
        }

        _onRowDetailsChange(rowDetails) {
          if (this._vaadinGrid && !rowDetails) {
            this._vaadinGrid.detailsOpenedItems = [];
          }
        }

        /**
         * Set visibility of the details container for any item's corresponding row.
         */
        setRowDetailsVisible(item, isVisible) {
          if (!item) {
            return;
          }
          const index = this._vaadinGrid.detailsOpenedItems.indexOf(item);
          if (isVisible && index < 0) {
            this._vaadinGrid.detailsOpenedItems.push(item);
            Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this._vaadinGrid.notifyResize());
          } else if (!isVisible && index >= 0) {
            this._vaadinGrid.detailsOpenedItems.splice(index, 1);
            Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this._vaadinGrid.notifyResize());
          }
        }

        _editingItemObserver(editingItem, oldV) {
          if (typeof oldV === 'undefined') {
            return;
          }

          this.dispatchEvent(new CustomEvent('editing-item-changed', {
            bubbles: true,
            composed: true,
            detail: {
              item: editingItem
            }
          }));
        }

        _setEditingItem(event) {
          this._editingItem = event.model.item;
        }

        _cancelEdit(event) {
          this._editingRenderers.forEach((renderer) => renderer.restoreInitial());
          this._editingItem = null;
        }

        _isItemEditing(item, editingItem) {
          return item === editingItem;
        }

        _isAnyItemEditing(editingItem) {
          return !!editingItem;
        }

        _saveItem() {
          if (this._editingRenderers.every((renderer) => renderer._performValidation().valid)) {
            this._editingRenderers.forEach((renderer) => renderer.applyValue());
            this._editingItem = null;
          }
        }

        _localizeChanged(localize) {
          this._boundedLocalize = localize.bind(this);
        }

        _scrollListener(e) {
          if (e.target.scrollLeft != 0) {
            this._vaadinGrid.setAttribute('horizontal-offset', 'true');
          } else {
            this._vaadinGrid.removeAttribute('horizontal-offset');
          }
        }

        /**
         * Overridden version of _onSorterChanged in vaadin-grid-sort-mixin. Is mapped to custom event
         * px-sorter-changed emitted by px-data-grid-sorter. Only difference is to use push, not
         * unshift, when adding sort rule to _sorters. If errors in this method, update to match with
         * current version in vaadin-grid-sort-mixin, and replace unshift with push.
         */
        _onPxSorterChanged(e) {

          this._pxDataGrid._editingItem = null;

          const sorter = e.target;

          this._removeArrayItem(this._sorters, sorter);
          sorter._order = null;

          if (this.multiSort) {
            if (sorter.direction) {
              this._sorters.push(sorter);
            }

            this._sorters.forEach((sorter, index) => sorter._order = this._sorters.length > 1 ? index : null, this);
          } else {
            this._sorters.forEach(sorter => {
              sorter._order = null;
              sorter.direction = null;
            });

            if (sorter.direction) {
              this._sorters = [sorter];
            }
          }

          e.stopPropagation();

          if (this.dataProvider &&
            // No need to clear cache if sorters didn't change
            JSON.stringify(this._previousSorters) !== JSON.stringify(this._mapSorters())) {
            this.clearCache();
          }

          this._a11yUpdateSorters();

          this._previousSorters = this._mapSorters();
        }

        _getOrderedColumns() {
          return this._vaadinGrid
            ._columnTree[this._vaadinGrid._columnTree.length - 1]
            .slice(0)
            .sort((a, b) => a._order - b._order)
            .map((col) => col.mappedObject);
        }

        _getVisibleColumns() {
          return this._vaadinGrid
            ._columnTree[this._vaadinGrid._columnTree.length - 1]
            .slice(0)
            .sort((a, b) => a._order - b._order)
            .map((col) => col.mappedObject)
            .filter((col) => !col.hidden);
        }

        /**
         * Returns currently visible data if `true` parameter is passed or all cached data if no parameter is passed.
         */
        getData(visibleOnly) {
          let items = [];

          if (visibleOnly) {
            items = Array.from(this._vaadinGrid.querySelectorAll('px-data-grid-cell-content-wrapper'));

            const gridRect = this._vaadinGrid.getBoundingClientRect();
            const headerRect = this._vaadinGrid
              .querySelector('px-data-grid-header-cell')
              .getBoundingClientRect();

            items = items.filter((wrapper) => {
              const wrapperRect = wrapper.getBoundingClientRect();
              return wrapperRect.top < gridRect.bottom && wrapperRect.bottom > headerRect.bottom;
            }).map((wrapper) => {
              return wrapper.item;
            }).filter((v, i, a) => {
              return a.indexOf(v) === i && v;
            });
          } else {
            const cachedItems = this._vaadinGrid._cache.items;
            Object.keys(cachedItems).forEach((key) => {
              items.push(cachedItems[key]);
            });
          }

          return items.map((item) => {
            const sortedObject = {};

            this._getVisibleColumns().forEach((col) => {
              sortedObject[col.path] = item[col.path];
            });

            return sortedObject;
          });
        }

        /**
         * Make JSON friendly version out of columns array
         */
        _cleanColumns(columns) {
          if (!columns) {
            return [];
          }
          return this._copyArray(columns);
        }

        /**
         * Columns property change observer
         */
        _columnsChanged(columns) {
          // Store cleaned version of current columns
          this._lastColumnsReceived = this._cleanColumns(columns);
        }

        _setColumnId(columns) {
          if (!columns || this._columnIdSetting) {
            return;
          }

          this._columnIdSetting = true;
          columns.forEach((column, index) => {
            if (!column.id) {
              this.set(`columns.${index}.id`, `${column.path}[${column.type || 'string'}]`);

              if (columns.filter((col) => col.id === column.id).length > 1) {
                console.warn(`Warning! There are multiple columns with '${column.path}' path ` +
                  `and '${column.type || 'string'}' type, please provide column.id for those columns`);
              }
            }
          });
          this._columnIdSetting = false;
        }

        /**
         * Restore layout (columns) to state those were given
         */
        restoreLayout() {
          if (!this._lastColumnsReceived) {
            console.warn('No layout defined where to return');
            return;
          }
          // Store last columns received before clearing columns
          const revertTo = this._copyArray(this._lastColumnsReceived);
          this._revertColumns(revertTo);
        }

        _revertColumns(revertTo) {
          // First clear all columns
          this.columns = [];

          // After empty columns has been rendered return to wanted state
          Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this.columns = revertTo);
        }

        /**
         * Just to make sure only true or false is given (undefined converted to false).
         * In some cases undefined value breaks functionality,
         */
        _undefinedToFalse(value) {
          if (value === undefined) {
            return false;
          } else {
            return value;
          }
        }

        _copyArray(arr) {
          return JSON.parse(JSON.stringify(arr));
        }

        getState() {
          return {
            columns: this._copyArray(this._getOrderedColumns()),
            highlight: this.highlight.map(entity => Object.assign({}, entity)),
            filters: this._copyArray(this.filters),
            autoFilter: this._autoFilterValue
          };
        }

        setState(state) {
          this.columns = [];

          Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => {
            this.columns = this._copyArray(state.columns);

            this.filters = state.filters;
            this._autoFilterValue = state.autoFilter;
            this.highlight = state.highlight;
          });
        }
      }
      customElements.define(DataGridElement.is, DataGridElement);

      /**
       * @namespace Predix
       */
      window.Predix = window.Predix || {};
      Predix.DataGridElement = DataGridElement;
    }
  </script>
</dom-module>
